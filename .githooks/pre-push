#!/bin/bash
# =====================================================
# Pre-Push Hook: Validation with PR-Aware Blocking
# =====================================================
#
# Runs validation scripts before push with context-aware
# blocking behavior:
#
#   - Push to branch WITH PR: BLOCKS if validation fails
#   - Push to branch WITHOUT PR: WARNS but allows push
#   - Creating/updating PR: Handled by gh pr create hooks
#
# Validation Scripts:
#   - elspais validate: REQ format and links
#   - elspais index validate: INDEX.md accuracy
#   - markdownlint: Markdown formatting
#   - gitleaks: Secret detection
#   - ./tool/test.sh: Dart and TypeScript tests (per app)
#
# To install this hook:
#   git config core.hooksPath .githooks
#
# To bypass (NOT RECOMMENDED for PR branches):
#   git push --no-verify
#
# =====================================================

set -e

# =====================================================
# anspar-wf plugin path (installed via pip)
# =====================================================
ANSPAR_PLUGINS="${ANSPAR_WF_PLUGINS:-$HOME/anspar-wf/plugins/plugins}"

# Portable version comparison: returns 0 (true) if $1 < $2
_ver_lt() {
    local IFS=.
    local i a=($1) b=($2)
    for ((i=0; i<${#b[@]}; i++)); do
        [[ -z "${a[i]}" ]] && a[i]=0
        if ((10#${a[i]} < 10#${b[i]})); then return 0; fi
        if ((10#${a[i]} > 10#${b[i]})); then return 1; fi
    done
    return 1
}

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Get the current branch
CURRENT_BRANCH=$(git branch --show-current)

# Skip validation for main/master branches (they should only receive validated PRs)
if [ "$CURRENT_BRANCH" = "main" ] || [ "$CURRENT_BRANCH" = "master" ]; then
    printf '%b\n' "${BLUE}Skipping pre-push validation for protected branch '$CURRENT_BRANCH'${NC}"
    exit 0
fi

# =====================================================
# 1. Detect PR Status and PR-Intended Branches
# =====================================================

HAS_PR=false
PR_URL=""
IS_PR_INTENDED_BRANCH=false

# Check if branch name indicates it's intended for a PR
# Per CLAUDE.md: feature/*, fix/*, release/* branches require PRs
if [[ "$CURRENT_BRANCH" == feature/* ]] || \
   [[ "$CURRENT_BRANCH" == fix/* ]] || \
   [[ "$CURRENT_BRANCH" == release/* ]]; then
    IS_PR_INTENDED_BRANCH=true
fi

# Check if gh CLI is available
if command -v gh &> /dev/null; then
    # Check if branch has an associated PR
    if PR_INFO=$(gh pr view "$CURRENT_BRANCH" --json url,state 2>/dev/null); then
        PR_STATE=$(echo "$PR_INFO" | jq -r '.state' 2>/dev/null)
        if [ "$PR_STATE" = "OPEN" ]; then
            HAS_PR=true
            PR_URL=$(echo "$PR_INFO" | jq -r '.url' 2>/dev/null)
        fi
    fi
else
    printf '%b\n' "${YELLOW}WARNING: gh CLI not installed - cannot detect PR status${NC}"
    printf '%b\n' "${YELLOW}         Install: https://cli.github.com/${NC}"
    echo ""
fi

# PR-intended branches should be blocking even before PR exists
# This ensures validation passes BEFORE creating a PR
SHOULD_BLOCK=$HAS_PR
if [ "$IS_PR_INTENDED_BRANCH" = true ]; then
    SHOULD_BLOCK=true
fi

# =====================================================
# 2. Run Validation Scripts
# =====================================================

echo ""
printf '%b\n' "${BLUE}======================================${NC}"
printf '%b\n' "${BLUE}  Pre-Push Validation${NC}"
printf '%b\n' "${BLUE}======================================${NC}"
echo ""

if [ "$SHOULD_BLOCK" = true ]; then
    if [ "$HAS_PR" = true ]; then
        printf '%b\n' "${BLUE}Branch '$CURRENT_BRANCH' has open PR:${NC}"
        printf '%b\n' "${BLUE}  $PR_URL${NC}"
    elif [ "$IS_PR_INTENDED_BRANCH" = true ]; then
        printf '%b\n' "${BLUE}Branch '$CURRENT_BRANCH' is a PR-intended branch (feature/fix/release).${NC}"
    fi
    printf '%b\n' "${RED}Validation failures will BLOCK this push.${NC}"
else
    printf '%b\n' "${YELLOW}Branch '$CURRENT_BRANCH' has no open PR.${NC}"
    printf '%b\n' "${YELLOW}Validation failures will show warnings only.${NC}"
fi
echo ""

VALIDATION_FAILED=false
VALIDATION_OUTPUT=""

# Get repo root
REPO_ROOT=$(git rev-parse --show-toplevel)

# Load central version pinning (used by multiple validation steps)
if [ -f "$REPO_ROOT/.github/versions.env" ]; then
    while IFS='=' read -r key value; do
        [[ "$key" =~ ^#.*$ ]] && continue
        [[ -z "$key" ]] && continue
        key=$(echo "$key" | xargs)
        value=$(echo "$value" | xargs)
        export "${key}=${value}"
    done < "$REPO_ROOT/.github/versions.env"
fi

# Check elspais version against minimum required
if [ -n "$ELSPAIS_VERSION" ]; then
    if command -v elspais &> /dev/null; then
        INSTALLED_ELSPAIS=$(elspais --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
        if [ -n "$INSTALLED_ELSPAIS" ]; then
            if _ver_lt "$INSTALLED_ELSPAIS" "$ELSPAIS_VERSION"; then
                printf '%b\n' "${RED}ERROR: elspais $INSTALLED_ELSPAIS is older than required $ELSPAIS_VERSION${NC}"
                echo ""
                echo "   Update with one of:"
                echo "     pip install --upgrade elspais"
                echo "     pipx upgrade elspais"
                echo "     brew tap anspar-org/anspar && brew upgrade elspais"
                echo ""
                exit 1
            fi
        fi
    else
        printf '%b\n' "${RED}ERROR: elspais is not installed (required: >= $ELSPAIS_VERSION)${NC}"
        echo ""
        echo "   Install with one of:"
        echo "     pip install elspais"
        echo "     pipx install elspais"
        echo "     brew tap anspar-org/anspar && brew install elspais"
        echo ""
        exit 1
    fi
fi

# Run elspais validate (REQ format and links)
printf '%b\n' "${BLUE}Running requirement validation...${NC}"
echo ""

if command -v elspais &> /dev/null; then
    if ! OUTPUT=$(elspais validate --mode core 2>&1); then
        VALIDATION_FAILED=true
        VALIDATION_OUTPUT+="$OUTPUT"
        echo "$OUTPUT"
    else
        echo "$OUTPUT"
    fi
else
    printf '%b\n' "${RED}ERROR: elspais not installed - requirement validation is required${NC}"
    VALIDATION_FAILED=true
fi

echo ""

# Run elspais index validate (INDEX.md accuracy)
printf '%b\n' "${BLUE}Running INDEX.md validation...${NC}"
echo ""

if command -v elspais &> /dev/null; then
    if ! OUTPUT=$(elspais index validate --mode core 2>&1); then
        VALIDATION_FAILED=true
        VALIDATION_OUTPUT+="$OUTPUT"
        echo "$OUTPUT"
    else
        echo "$OUTPUT"
    fi
else
    printf '%b\n' "${RED}ERROR: elspais not installed - INDEX.md validation is required${NC}"
    VALIDATION_FAILED=true
fi

echo ""

# =====================================================
# 3. Markdown Linting
# =====================================================

# Get list of markdown files that will be pushed
# Compare local branch to remote tracking branch
REMOTE_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || echo "")

# Determine all changed files (used by multiple validation steps)
if [ -n "$REMOTE_BRANCH" ]; then
    CHANGED_FILES=$(git diff --name-only "$REMOTE_BRANCH"...HEAD 2>/dev/null || true)
else
    CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || true)
fi

if [ -n "$REMOTE_BRANCH" ]; then
    MARKDOWN_FILES_CHANGED=$(git diff --name-only "$REMOTE_BRANCH"...HEAD 2>/dev/null | grep '\.md$' | grep -v 'untracked-notes/' || true)
else
    # No remote tracking branch - check all committed but unpushed markdown files
    MARKDOWN_FILES_CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | grep '\.md$' | grep -v 'untracked-notes/' || true)
fi

if [ -n "$MARKDOWN_FILES_CHANGED" ]; then
    printf '%b\n' "${BLUE}Running markdown linting...${NC}"
    echo ""

    # Check if markdownlint-cli is installed
    if command -v markdownlint &> /dev/null; then
        MARKDOWNLINT_FAILED=0

        # Filter to only files that exist (in case of deletions)
        EXISTING_FILES=""
        while IFS= read -r file; do
            if [ -f "$REPO_ROOT/$file" ]; then
                EXISTING_FILES+="$REPO_ROOT/$file"$'\n'
            fi
        done <<< "$MARKDOWN_FILES_CHANGED"

        if [ -n "$EXISTING_FILES" ]; then
            # Lint all changed markdown files at once
            if ! echo "$EXISTING_FILES" | xargs markdownlint --config "$REPO_ROOT/.markdownlint.json" 2>&1; then
                MARKDOWNLINT_FAILED=1
            fi

            if [ $MARKDOWNLINT_FAILED -eq 1 ]; then
                VALIDATION_FAILED=true
                echo ""
                printf '%b\n' "${RED}Markdown linting failed!${NC}"
                echo ""
            else
                printf '%b\n' "${GREEN}Markdown linting passed!${NC}"
            fi
        fi
    else
        printf '%b\n' "${YELLOW}WARNING: markdownlint not installed - skipping markdown linting${NC}"
        printf '%b\n' "${YELLOW}         Install: npm install -g markdownlint-cli@${MARKDOWNLINT_CLI_VERSION:-latest}${NC}"
    fi
    echo ""
else
    printf '%b\n' "${BLUE}No markdown files changed - skipping markdown linting${NC}"
    echo ""
fi

# =====================================================
# 4. Secret Detection (Gitleaks)
# =====================================================

printf '%b\n' "${BLUE}Running secret detection...${NC}"
echo ""

if command -v gitleaks &> /dev/null; then
    # Run gitleaks on the commits being pushed
    if [ -n "$REMOTE_BRANCH" ]; then
        # Check commits between remote and local
        if ! gitleaks detect --source="$REPO_ROOT" --log-opts="$REMOTE_BRANCH..HEAD" --no-banner --redact 2>&1; then
            VALIDATION_FAILED=true
            echo ""
            printf '%b\n' "${RED}Gitleaks detected secrets!${NC}"
            printf '%b\n' "${RED}Remove secrets before pushing.${NC}"
            echo ""
        else
            printf '%b\n' "${GREEN}No secrets detected!${NC}"
        fi
    else
        # No remote - scan the whole repo
        if ! gitleaks detect --source="$REPO_ROOT" --no-banner --redact 2>&1; then
            VALIDATION_FAILED=true
            echo ""
            printf '%b\n' "${RED}Gitleaks detected secrets!${NC}"
            echo ""
        else
            printf '%b\n' "${GREEN}No secrets detected!${NC}"
        fi
    fi
else
    printf '%b\n' "${RED}ERROR: gitleaks not installed - secret detection is required${NC}"
    printf '%b\n' "${RED}       Install: https://github.com/gitleaks/gitleaks#installing${NC}"
    echo ""
    VALIDATION_FAILED=true
fi

echo ""

# =====================================================
# 5. Find app directories affected by changes
# =====================================================
# Only run pub get, format, and analyze on apps with changed files.
# Walk up from each changed Dart file to find the nearest pubspec.yaml.
#
# IMPORTANT: Unset GIT_DIR/GIT_WORK_TREE before running Flutter/Dart commands.
# Git hooks set these env vars, which causes Flutter to read version info from
# the project repo instead of the Flutter SDK repo, resulting in "0.0.0-unknown".
unset GIT_DIR GIT_WORK_TREE

AFFECTED_APP_DIRS=""
while IFS= read -r changed_file; do
    if [[ "$changed_file" == apps/* ]] && [[ "$changed_file" == *.dart ]]; then
        DIR="$REPO_ROOT/$(dirname "$changed_file")"
        while [[ "$DIR" == "$REPO_ROOT/apps"* ]] && [ "$DIR" != "$REPO_ROOT/apps" ]; do
            if [ -f "$DIR/pubspec.yaml" ]; then
                REL_DIR=${DIR#"$REPO_ROOT"/}
                if ! echo "$AFFECTED_APP_DIRS" | grep -q "^$REL_DIR$"; then
                    AFFECTED_APP_DIRS="$AFFECTED_APP_DIRS
$REL_DIR"
                fi
                break
            fi
            DIR=$(dirname "$DIR")
        done
    fi
done <<< "$CHANGED_FILES"
AFFECTED_APP_DIRS=$(echo "$AFFECTED_APP_DIRS" | sed '/^$/d')

if [ -z "$AFFECTED_APP_DIRS" ]; then
    printf '%b\n' "${BLUE}No Dart files changed - skipping pub get, format, and analyze${NC}"
    echo ""
else
    # -------------------------------------------------
    # 5.1. Dart Pub Get (dependency resolution)
    # -------------------------------------------------
    printf '%b\n' "${BLUE}Resolving Dart dependencies for affected apps...${NC}"
    echo ""

    if command -v dart &> /dev/null; then
        while IFS= read -r app_dir; do
            FULL_DIR="$REPO_ROOT/$app_dir"
            PUBSPEC="$FULL_DIR/pubspec.yaml"
            APP_NAME=${app_dir#apps/}

            echo "  Getting dependencies for $APP_NAME..."

            if [ -f "$FULL_DIR/lib/main.dart" ] || grep -q "flutter:" "$PUBSPEC" 2>/dev/null; then
                if command -v flutter &> /dev/null; then
                    (cd "$FULL_DIR" && flutter pub get --suppress-analytics) > /dev/null 2>&1 || true
                else
                    (cd "$FULL_DIR" && dart pub get) > /dev/null 2>&1 || true
                fi
            else
                (cd "$FULL_DIR" && dart pub get) > /dev/null 2>&1 || true
            fi
        done <<< "$AFFECTED_APP_DIRS"
        printf '%b\n' "${GREEN}Dependencies resolved${NC}"
    else
        printf '%b\n' "${YELLOW}WARNING: dart not available - skipping dependency resolution${NC}"
    fi
    echo ""

    # -------------------------------------------------
    # 5.2. Dart Format Check
    # -------------------------------------------------
    printf '%b\n' "${BLUE}Checking Dart formatting...${NC}"
    echo ""

    if command -v dart &> /dev/null; then
        DART_FORMAT_FAILED=false

        while IFS= read -r app_dir; do
            FULL_DIR="$REPO_ROOT/$app_dir"
            APP_NAME=${app_dir#apps/}

            echo "  Checking $APP_NAME..."

            if ! (cd "$FULL_DIR" && dart format --output=none --set-exit-if-changed . 2>&1); then
                DART_FORMAT_FAILED=true
                echo ""
                printf '%b\n' "${RED}  ❌ $APP_NAME has unformatted Dart files${NC}"
                echo ""
            else
                printf '%b\n' "${GREEN}  ✅ $APP_NAME formatting OK${NC}"
            fi
        done <<< "$AFFECTED_APP_DIRS"

        if [ "$DART_FORMAT_FAILED" = true ]; then
            VALIDATION_FAILED=true
            echo ""
            printf '%b\n' "${RED}Dart format check failed!${NC}"
            printf '%b\n' "${RED}Run 'dart format .' in the affected app directories.${NC}"
            echo ""
        else
            echo ""
            printf '%b\n' "${GREEN}Dart format check passed!${NC}"
        fi
    else
        printf '%b\n' "${RED}ERROR: dart not installed - Dart format check is required${NC}"
        printf '%b\n' "${RED}       Install Flutter/Dart: https://docs.flutter.dev/get-started/install${NC}"
        echo ""
        VALIDATION_FAILED=true
    fi
    echo ""

    # -------------------------------------------------
    # 5.3. Dart Analyze Check
    # -------------------------------------------------
    printf '%b\n' "${BLUE}Running Dart static analysis...${NC}"
    echo ""

    if command -v dart &> /dev/null; then
        DART_ANALYZE_FAILED=false

        while IFS= read -r app_dir; do
            FULL_DIR="$REPO_ROOT/$app_dir"
            APP_NAME=${app_dir#apps/}

            echo "  Analyzing $APP_NAME..."

            if ! (cd "$FULL_DIR" && dart analyze --fatal-infos 2>&1); then
                DART_ANALYZE_FAILED=true
                echo ""
                printf '%b\n' "${RED}  ❌ $APP_NAME has analysis issues${NC}"
                echo ""
            else
                printf '%b\n' "${GREEN}  ✅ $APP_NAME analysis OK${NC}"
            fi
        done <<< "$AFFECTED_APP_DIRS"

        if [ "$DART_ANALYZE_FAILED" = true ]; then
            VALIDATION_FAILED=true
            echo ""
            printf '%b\n' "${RED}Dart analyze check failed!${NC}"
            printf '%b\n' "${RED}Fix all analysis issues (including infos) before pushing.${NC}"
            echo ""
        else
            echo ""
            printf '%b\n' "${GREEN}Dart analyze check passed!${NC}"
        fi
    else
        printf '%b\n' "${RED}ERROR: dart not installed - Dart analyze check is required${NC}"
        echo ""
        VALIDATION_FAILED=true
    fi
    echo ""
fi

# =====================================================
# 6. Auto-Discover and Execute Plugin Pre-Push Hooks
# =====================================================

PLUGIN_DIR="$ANSPAR_PLUGINS"

if [ -d "$PLUGIN_DIR" ]; then
    # Find all plugin pre-push hooks
    PLUGIN_HOOKS=$(find "$PLUGIN_DIR" -type f -path "*/hooks/pre-push" 2>/dev/null | sort)

    if [ -n "$PLUGIN_HOOKS" ]; then
        while IFS= read -r hook; do
            PLUGIN_NAME=$(echo "$hook" | sed 's|.*/plugins/\([^/]*\)/.*|\1|')

            # Execute the hook if it's executable
            if [ -x "$hook" ]; then
                printf '%b\n' "${BLUE}Running plugin hook: $PLUGIN_NAME${NC}"
                if ! "$hook"; then
                    VALIDATION_FAILED=true
                    printf '%b\n' "${RED}Plugin hook failed: $PLUGIN_NAME${NC}"
                fi
            fi
        done <<< "$PLUGIN_HOOKS"
    fi
fi

# =====================================================
# Project Definitions (shared with pre-commit hook)
# =====================================================
HOOK_DIR=$(cd "$(dirname "$0")" && pwd)
source "$HOOK_DIR/project-defs.sh"

# =====================================================
# 7. Run Test Suites (./tool/test.sh)
# =====================================================
#
# Uses dependency-aware trigger paths from PROJECT_DEFS so that
# a source change in a dependency also triggers tests in dependents.
# e.g., a .dart change in trial_data_types runs clinical_diary tests.

printf '%b\n' "${BLUE}Running test suites...${NC}"
echo ""

# Find projects whose trigger paths have source file changes
TEST_DIRS=""
for project_def in "${PROJECT_DEFS[@]}"; do
    IFS='|' read -r name pubspec triggers <<< "$project_def"

    PROJECT_DIR=$(dirname "$pubspec")
    TEST_SCRIPT="$REPO_ROOT/$PROJECT_DIR/tool/test.sh"

    # Skip if no test script
    if [ ! -f "$TEST_SCRIPT" ] || [ ! -x "$TEST_SCRIPT" ]; then
        continue
    fi

    # Check if any trigger path has source file changes
    should_test=false
    for trigger in $triggers; do
        relevant=$(echo "$CHANGED_FILES" | grep "^${trigger}" | grep -E '\.(dart)$|tool/test\.sh$' || true)
        if [ -n "$relevant" ]; then
            should_test=true
            break
        fi
    done

    if [ "$should_test" = true ]; then
        if ! echo "$TEST_DIRS" | grep -q "^$PROJECT_DIR$"; then
            TEST_DIRS="$TEST_DIRS
$PROJECT_DIR"
        fi
    fi
done

# Remove leading newline
TEST_DIRS=$(echo "$TEST_DIRS" | sed '/^$/d')

if [ -n "$TEST_DIRS" ]; then
    while IFS= read -r app_dir; do
        TEST_SCRIPT="$REPO_ROOT/$app_dir/tool/test.sh"
        printf '%b\n' "${BLUE}Running tests for: $app_dir${NC}"
        echo ""

        # Resolve dependencies before running tests
        PUBSPEC_FILE="$REPO_ROOT/$app_dir/pubspec.yaml"
        if [ -f "$PUBSPEC_FILE" ]; then
            if grep -q "flutter:" "$PUBSPEC_FILE" 2>/dev/null && command -v flutter &> /dev/null; then
                (cd "$REPO_ROOT/$app_dir" && flutter pub get --suppress-analytics) > /dev/null 2>&1 || true
            elif command -v dart &> /dev/null; then
                (cd "$REPO_ROOT/$app_dir" && dart pub get) > /dev/null 2>&1 || true
            fi
        fi

        # Run unit tests only (integration tests require system deps like cmake/xvfb)
        if ! "$TEST_SCRIPT" -u; then
            VALIDATION_FAILED=true
            echo ""
            printf '%b\n' "${RED}Tests failed in $app_dir${NC}"
            echo ""
        else
            echo ""
            printf '%b\n' "${GREEN}Tests passed in $app_dir${NC}"
            echo ""
        fi
    done <<< "$TEST_DIRS"
else
    printf '%b\n' "${BLUE}No app directories with test.sh affected by changes${NC}"
    echo ""
fi

# =====================================================
# 8. Handle Validation Results
# =====================================================

echo ""
printf '%b\n' "${BLUE}======================================${NC}"
printf '%b\n' "${BLUE}  Validation Summary${NC}"
printf '%b\n' "${BLUE}======================================${NC}"
echo ""

if [ "$VALIDATION_FAILED" = true ]; then
    if [ "$SHOULD_BLOCK" = true ]; then
        # PR exists or PR-intended branch - BLOCK the push
        printf '%b\n' "${RED}VALIDATION FAILED${NC}"
        echo ""
        if [ "$HAS_PR" = true ]; then
            printf '%b\n' "${RED}Push BLOCKED because branch has an open PR.${NC}"
        elif [ "$IS_PR_INTENDED_BRANCH" = true ]; then
            printf '%b\n' "${RED}Push BLOCKED because this is a PR-intended branch (feature/fix/release).${NC}"
        fi
        printf '%b\n' "${RED}PR branches must pass all validations.${NC}"
        echo ""
        echo "To fix:"
        echo "  1. Review the validation errors above"
        echo "  2. Fix the issues in your code"
        echo "  3. Commit the fixes"
        echo "  4. Push again"
        echo ""
        printf '%b\n' "${YELLOW}To bypass (NOT RECOMMENDED):${NC}"
        echo "  git push --no-verify"
        echo ""
        exit 1
    else
        # No PR and not a PR-intended branch - warn but allow push
        printf '%b\n' "${YELLOW}VALIDATION FAILED (warnings only)${NC}"
        echo ""
        printf '%b\n' "${YELLOW}Push ALLOWED because branch has no open PR.${NC}"
        printf '%b\n' "${YELLOW}Fix these issues before creating a PR.${NC}"
        echo ""
        exit 0
    fi
else
    printf '%b\n' "${GREEN}ALL VALIDATIONS PASSED${NC}"
    echo ""
    exit 0
fi
