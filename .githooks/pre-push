#!/bin/bash
# =====================================================
# Pre-Push Hook: Validation with PR-Aware Blocking
# =====================================================
#
# Runs validation scripts before push with context-aware
# blocking behavior:
#
#   - Push to branch WITH PR: BLOCKS if validation fails
#   - Push to branch WITHOUT PR: WARNS but allows push
#   - Creating/updating PR: Handled by gh pr create hooks
#
# Validation Scripts:
#   - elspais validate: REQ format and links
#   - elspais index validate: INDEX.md accuracy
#   - markdownlint: Markdown formatting
#   - gitleaks: Secret detection
#   - ./tool/test.sh: Dart and TypeScript tests (per app)
#
# To install this hook:
#   git config core.hooksPath .githooks
#
# To bypass (NOT RECOMMENDED for PR branches):
#   git push --no-verify
#
# =====================================================

set -e

# =====================================================
# anspar-wf plugin path (installed via pip)
# =====================================================
ANSPAR_PLUGINS="${ANSPAR_WF_PLUGINS:-$HOME/anspar-wf/plugins/plugins}"

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Get the current branch
CURRENT_BRANCH=$(git branch --show-current)

# Skip validation for main/master branches (they should only receive validated PRs)
if [ "$CURRENT_BRANCH" = "main" ] || [ "$CURRENT_BRANCH" = "master" ]; then
    echo -e "${BLUE}Skipping pre-push validation for protected branch '$CURRENT_BRANCH'${NC}"
    exit 0
fi

# =====================================================
# 1. Detect PR Status and PR-Intended Branches
# =====================================================

HAS_PR=false
PR_URL=""
IS_PR_INTENDED_BRANCH=false

# Check if branch name indicates it's intended for a PR
# Per CLAUDE.md: feature/*, fix/*, release/* branches require PRs
if [[ "$CURRENT_BRANCH" == feature/* ]] || \
   [[ "$CURRENT_BRANCH" == fix/* ]] || \
   [[ "$CURRENT_BRANCH" == release/* ]]; then
    IS_PR_INTENDED_BRANCH=true
fi

# Check if gh CLI is available
if command -v gh &> /dev/null; then
    # Check if branch has an associated PR
    if PR_INFO=$(gh pr view "$CURRENT_BRANCH" --json url,state 2>/dev/null); then
        PR_STATE=$(echo "$PR_INFO" | jq -r '.state' 2>/dev/null)
        if [ "$PR_STATE" = "OPEN" ]; then
            HAS_PR=true
            PR_URL=$(echo "$PR_INFO" | jq -r '.url' 2>/dev/null)
        fi
    fi
else
    echo -e "${YELLOW}WARNING: gh CLI not installed - cannot detect PR status${NC}"
    echo -e "${YELLOW}         Install: https://cli.github.com/${NC}"
    echo ""
fi

# PR-intended branches should be blocking even before PR exists
# This ensures validation passes BEFORE creating a PR
SHOULD_BLOCK=$HAS_PR
if [ "$IS_PR_INTENDED_BRANCH" = true ]; then
    SHOULD_BLOCK=true
fi

# =====================================================
# 2. Run Validation Scripts
# =====================================================

echo ""
echo -e "${BLUE}======================================${NC}"
echo -e "${BLUE}  Pre-Push Validation${NC}"
echo -e "${BLUE}======================================${NC}"
echo ""

if [ "$SHOULD_BLOCK" = true ]; then
    if [ "$HAS_PR" = true ]; then
        echo -e "${BLUE}Branch '$CURRENT_BRANCH' has open PR:${NC}"
        echo -e "${BLUE}  $PR_URL${NC}"
    elif [ "$IS_PR_INTENDED_BRANCH" = true ]; then
        echo -e "${BLUE}Branch '$CURRENT_BRANCH' is a PR-intended branch (feature/fix/release).${NC}"
    fi
    echo -e "${RED}Validation failures will BLOCK this push.${NC}"
else
    echo -e "${YELLOW}Branch '$CURRENT_BRANCH' has no open PR.${NC}"
    echo -e "${YELLOW}Validation failures will show warnings only.${NC}"
fi
echo ""

VALIDATION_FAILED=false
VALIDATION_OUTPUT=""

# Get repo root
REPO_ROOT=$(git rev-parse --show-toplevel)

# Load central version pinning (used by multiple validation steps)
if [ -f "$REPO_ROOT/.github/versions.env" ]; then
    while IFS='=' read -r key value; do
        [[ "$key" =~ ^#.*$ ]] && continue
        [[ -z "$key" ]] && continue
        key=$(echo "$key" | xargs)
        value=$(echo "$value" | xargs)
        export "${key}=${value}"
    done < "$REPO_ROOT/.github/versions.env"
fi

# Check elspais version against minimum required
if [ -n "$ELSPAIS_VERSION" ]; then
    if command -v elspais &> /dev/null; then
        INSTALLED_ELSPAIS=$(elspais --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
        if [ -n "$INSTALLED_ELSPAIS" ]; then
            if [ "$(printf '%s\n%s\n' "$INSTALLED_ELSPAIS" "$ELSPAIS_VERSION" | sort -V | head -n1)" != "$ELSPAIS_VERSION" ]; then
                echo -e "${RED}ERROR: elspais $INSTALLED_ELSPAIS is older than required $ELSPAIS_VERSION${NC}"
                echo ""
                echo "   Update with one of:"
                echo "     pip install --upgrade elspais"
                echo "     pipx upgrade elspais"
                echo "     brew tap anspar-org/anspar && brew upgrade elspais"
                echo ""
                exit 1
            fi
        fi
    else
        echo -e "${RED}ERROR: elspais is not installed (required: >= $ELSPAIS_VERSION)${NC}"
        echo ""
        echo "   Install with one of:"
        echo "     pip install elspais"
        echo "     pipx install elspais"
        echo "     brew tap anspar-org/anspar && brew install elspais"
        echo ""
        exit 1
    fi
fi

# Run elspais validate (REQ format and links)
echo -e "${BLUE}Running requirement validation...${NC}"
echo ""

if command -v elspais &> /dev/null; then
    if ! OUTPUT=$(elspais validate --mode core 2>&1); then
        VALIDATION_FAILED=true
        VALIDATION_OUTPUT+="$OUTPUT"
        echo "$OUTPUT"
    else
        echo "$OUTPUT"
    fi
else
    echo -e "${RED}ERROR: elspais not installed - requirement validation is required${NC}"
    VALIDATION_FAILED=true
fi

echo ""

# Run elspais index validate (INDEX.md accuracy)
echo -e "${BLUE}Running INDEX.md validation...${NC}"
echo ""

if command -v elspais &> /dev/null; then
    if ! OUTPUT=$(elspais index validate --mode core 2>&1); then
        VALIDATION_FAILED=true
        VALIDATION_OUTPUT+="$OUTPUT"
        echo "$OUTPUT"
    else
        echo "$OUTPUT"
    fi
else
    echo -e "${RED}ERROR: elspais not installed - INDEX.md validation is required${NC}"
    VALIDATION_FAILED=true
fi

echo ""

# =====================================================
# 3. Markdown Linting
# =====================================================

# Get list of markdown files that will be pushed
# Compare local branch to remote tracking branch
REMOTE_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || echo "")

# Determine all changed files (used by multiple validation steps)
if [ -n "$REMOTE_BRANCH" ]; then
    CHANGED_FILES=$(git diff --name-only "$REMOTE_BRANCH"...HEAD 2>/dev/null || true)
else
    CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || true)
fi

if [ -n "$REMOTE_BRANCH" ]; then
    MARKDOWN_FILES_CHANGED=$(git diff --name-only "$REMOTE_BRANCH"...HEAD 2>/dev/null | grep '\.md$' | grep -v 'untracked-notes/' || true)
else
    # No remote tracking branch - check all committed but unpushed markdown files
    MARKDOWN_FILES_CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | grep '\.md$' | grep -v 'untracked-notes/' || true)
fi

if [ -n "$MARKDOWN_FILES_CHANGED" ]; then
    echo -e "${BLUE}Running markdown linting...${NC}"
    echo ""

    # Check if markdownlint-cli is installed
    if command -v markdownlint &> /dev/null; then
        MARKDOWNLINT_FAILED=0

        # Filter to only files that exist (in case of deletions)
        EXISTING_FILES=""
        while IFS= read -r file; do
            if [ -f "$REPO_ROOT/$file" ]; then
                EXISTING_FILES+="$REPO_ROOT/$file"$'\n'
            fi
        done <<< "$MARKDOWN_FILES_CHANGED"

        if [ -n "$EXISTING_FILES" ]; then
            # Lint all changed markdown files at once
            if ! echo "$EXISTING_FILES" | xargs markdownlint --config "$REPO_ROOT/.markdownlint.json" 2>&1; then
                MARKDOWNLINT_FAILED=1
            fi

            if [ $MARKDOWNLINT_FAILED -eq 1 ]; then
                VALIDATION_FAILED=true
                echo ""
                echo -e "${RED}Markdown linting failed!${NC}"
                echo ""
            else
                echo -e "${GREEN}Markdown linting passed!${NC}"
            fi
        fi
    else
        echo -e "${YELLOW}WARNING: markdownlint not installed - skipping markdown linting${NC}"
        echo -e "${YELLOW}         Install: npm install -g markdownlint-cli@${MARKDOWNLINT_CLI_VERSION:-latest}${NC}"
    fi
    echo ""
else
    echo -e "${BLUE}No markdown files changed - skipping markdown linting${NC}"
    echo ""
fi

# =====================================================
# 4. Secret Detection (Gitleaks)
# =====================================================

echo -e "${BLUE}Running secret detection...${NC}"
echo ""

if command -v gitleaks &> /dev/null; then
    # Run gitleaks on the commits being pushed
    if [ -n "$REMOTE_BRANCH" ]; then
        # Check commits between remote and local
        if ! gitleaks detect --source="$REPO_ROOT" --log-opts="$REMOTE_BRANCH..HEAD" --no-banner --redact 2>&1; then
            VALIDATION_FAILED=true
            echo ""
            echo -e "${RED}Gitleaks detected secrets!${NC}"
            echo -e "${RED}Remove secrets before pushing.${NC}"
            echo ""
        else
            echo -e "${GREEN}No secrets detected!${NC}"
        fi
    else
        # No remote - scan the whole repo
        if ! gitleaks detect --source="$REPO_ROOT" --no-banner --redact 2>&1; then
            VALIDATION_FAILED=true
            echo ""
            echo -e "${RED}Gitleaks detected secrets!${NC}"
            echo ""
        else
            echo -e "${GREEN}No secrets detected!${NC}"
        fi
    fi
else
    echo -e "${RED}ERROR: gitleaks not installed - secret detection is required${NC}"
    echo -e "${RED}       Install: https://github.com/gitleaks/gitleaks#installing${NC}"
    echo ""
    VALIDATION_FAILED=true
fi

echo ""

# =====================================================
# 5. Find app directories affected by changes
# =====================================================
# Only run pub get, format, and analyze on apps with changed files.
# Walk up from each changed Dart file to find the nearest pubspec.yaml.
#
# IMPORTANT: Unset GIT_DIR/GIT_WORK_TREE before running Flutter/Dart commands.
# Git hooks set these env vars, which causes Flutter to read version info from
# the project repo instead of the Flutter SDK repo, resulting in "0.0.0-unknown".
unset GIT_DIR GIT_WORK_TREE

AFFECTED_APP_DIRS=""
while IFS= read -r changed_file; do
    if [[ "$changed_file" == apps/* ]] && [[ "$changed_file" == *.dart ]]; then
        DIR="$REPO_ROOT/$(dirname "$changed_file")"
        while [[ "$DIR" == "$REPO_ROOT/apps"* ]] && [ "$DIR" != "$REPO_ROOT/apps" ]; do
            if [ -f "$DIR/pubspec.yaml" ]; then
                REL_DIR=${DIR#$REPO_ROOT/}
                if ! echo "$AFFECTED_APP_DIRS" | grep -q "^$REL_DIR$"; then
                    AFFECTED_APP_DIRS="$AFFECTED_APP_DIRS
$REL_DIR"
                fi
                break
            fi
            DIR=$(dirname "$DIR")
        done
    fi
done <<< "$CHANGED_FILES"
AFFECTED_APP_DIRS=$(echo "$AFFECTED_APP_DIRS" | sed '/^$/d')

if [ -z "$AFFECTED_APP_DIRS" ]; then
    echo -e "${BLUE}No Dart files changed - skipping pub get, format, and analyze${NC}"
    echo ""
else
    # -------------------------------------------------
    # 5.1. Dart Pub Get (dependency resolution)
    # -------------------------------------------------
    echo -e "${BLUE}Resolving Dart dependencies for affected apps...${NC}"
    echo ""

    if command -v dart &> /dev/null; then
        while IFS= read -r app_dir; do
            FULL_DIR="$REPO_ROOT/$app_dir"
            PUBSPEC="$FULL_DIR/pubspec.yaml"
            APP_NAME=${app_dir#apps/}

            echo "  Getting dependencies for $APP_NAME..."

            if [ -f "$FULL_DIR/lib/main.dart" ] || grep -q "flutter:" "$PUBSPEC" 2>/dev/null; then
                if command -v flutter &> /dev/null; then
                    (cd "$FULL_DIR" && flutter pub get --suppress-analytics) > /dev/null 2>&1 || true
                else
                    (cd "$FULL_DIR" && dart pub get) > /dev/null 2>&1 || true
                fi
            else
                (cd "$FULL_DIR" && dart pub get) > /dev/null 2>&1 || true
            fi
        done <<< "$AFFECTED_APP_DIRS"
        echo -e "${GREEN}Dependencies resolved${NC}"
    else
        echo -e "${YELLOW}WARNING: dart not available - skipping dependency resolution${NC}"
    fi
    echo ""

    # -------------------------------------------------
    # 5.2. Dart Format Check
    # -------------------------------------------------
    echo -e "${BLUE}Checking Dart formatting...${NC}"
    echo ""

    if command -v dart &> /dev/null; then
        DART_FORMAT_FAILED=false

        while IFS= read -r app_dir; do
            FULL_DIR="$REPO_ROOT/$app_dir"
            APP_NAME=${app_dir#apps/}

            echo "  Checking $APP_NAME..."

            if ! (cd "$FULL_DIR" && dart format --output=none --set-exit-if-changed . 2>&1); then
                DART_FORMAT_FAILED=true
                echo ""
                echo -e "${RED}  ❌ $APP_NAME has unformatted Dart files${NC}"
                echo ""
            else
                echo -e "${GREEN}  ✅ $APP_NAME formatting OK${NC}"
            fi
        done <<< "$AFFECTED_APP_DIRS"

        if [ "$DART_FORMAT_FAILED" = true ]; then
            VALIDATION_FAILED=true
            echo ""
            echo -e "${RED}Dart format check failed!${NC}"
            echo -e "${RED}Run 'dart format .' in the affected app directories.${NC}"
            echo ""
        else
            echo ""
            echo -e "${GREEN}Dart format check passed!${NC}"
        fi
    else
        echo -e "${RED}ERROR: dart not installed - Dart format check is required${NC}"
        echo -e "${RED}       Install Flutter/Dart: https://docs.flutter.dev/get-started/install${NC}"
        echo ""
        VALIDATION_FAILED=true
    fi
    echo ""

    # -------------------------------------------------
    # 5.3. Dart Analyze Check
    # -------------------------------------------------
    echo -e "${BLUE}Running Dart static analysis...${NC}"
    echo ""

    if command -v dart &> /dev/null; then
        DART_ANALYZE_FAILED=false

        while IFS= read -r app_dir; do
            FULL_DIR="$REPO_ROOT/$app_dir"
            APP_NAME=${app_dir#apps/}

            echo "  Analyzing $APP_NAME..."

            if ! (cd "$FULL_DIR" && dart analyze --fatal-infos 2>&1); then
                DART_ANALYZE_FAILED=true
                echo ""
                echo -e "${RED}  ❌ $APP_NAME has analysis issues${NC}"
                echo ""
            else
                echo -e "${GREEN}  ✅ $APP_NAME analysis OK${NC}"
            fi
        done <<< "$AFFECTED_APP_DIRS"

        if [ "$DART_ANALYZE_FAILED" = true ]; then
            VALIDATION_FAILED=true
            echo ""
            echo -e "${RED}Dart analyze check failed!${NC}"
            echo -e "${RED}Fix all analysis issues (including infos) before pushing.${NC}"
            echo ""
        else
            echo ""
            echo -e "${GREEN}Dart analyze check passed!${NC}"
        fi
    else
        echo -e "${RED}ERROR: dart not installed - Dart analyze check is required${NC}"
        echo ""
        VALIDATION_FAILED=true
    fi
    echo ""
fi

# =====================================================
# 6. Auto-Discover and Execute Plugin Pre-Push Hooks
# =====================================================

PLUGIN_DIR="$ANSPAR_PLUGINS"

if [ -d "$PLUGIN_DIR" ]; then
    # Find all plugin pre-push hooks
    PLUGIN_HOOKS=$(find "$PLUGIN_DIR" -type f -path "*/hooks/pre-push" 2>/dev/null | sort)

    if [ -n "$PLUGIN_HOOKS" ]; then
        while IFS= read -r hook; do
            PLUGIN_NAME=$(echo "$hook" | sed 's|.*/plugins/\([^/]*\)/.*|\1|')

            # Execute the hook if it's executable
            if [ -x "$hook" ]; then
                echo -e "${BLUE}Running plugin hook: $PLUGIN_NAME${NC}"
                if ! "$hook"; then
                    VALIDATION_FAILED=true
                    echo -e "${RED}Plugin hook failed: $PLUGIN_NAME${NC}"
                fi
            fi
        done <<< "$PLUGIN_HOOKS"
    fi
fi

# =====================================================
# Project Definitions (shared by test and bump sections)
# =====================================================
#
# Each entry: name|pubspec_path|trigger_paths (space-separated)
# Trigger paths include transitive dependencies so that a change
# in a dependency triggers tests and bumps in dependents.
# e.g., a change in trial_data_types tests and bumps clinical_diary.
PROJECT_DEFS=(
    # Deployable apps
    "clinical_diary|apps/daily-diary/clinical_diary/pubspec.yaml|apps/daily-diary/clinical_diary/ apps/common-dart/trial_data_types/ apps/common-dart/append_only_datastore/ apps/daily-diary/diary_functions/ apps/common-flutter/eq/"
    "portal-ui|apps/sponsor-portal/portal-ui/pubspec.yaml|apps/sponsor-portal/portal-ui/ apps/sponsor-portal/portal_functions/ apps/common-dart/trial_data_types/"
    "diary_server|apps/daily-diary/diary_server/pubspec.yaml|apps/daily-diary/diary_server/ apps/daily-diary/diary_functions/ apps/common-dart/trial_data_types/ database/"
    "portal_server|apps/sponsor-portal/portal_server/pubspec.yaml|apps/sponsor-portal/portal_server/ apps/sponsor-portal/portal_functions/ apps/common-dart/trial_data_types/ database/"
    # Libraries
    "trial_data_types|apps/common-dart/trial_data_types/pubspec.yaml|apps/common-dart/trial_data_types/"
    "append_only_datastore|apps/common-dart/append_only_datastore/pubspec.yaml|apps/common-dart/append_only_datastore/"
    "diary_functions|apps/daily-diary/diary_functions/pubspec.yaml|apps/daily-diary/diary_functions/ apps/common-dart/trial_data_types/"
    "portal_functions|apps/sponsor-portal/portal_functions/pubspec.yaml|apps/sponsor-portal/portal_functions/ apps/common-dart/trial_data_types/"
    "eq|apps/common-flutter/eq/pubspec.yaml|apps/common-flutter/eq/ apps/common-dart/trial_data_types/"
    "rave-integration|apps/edc/rave-integration/pubspec.yaml|apps/edc/rave-integration/"
)

# =====================================================
# 7. Run Test Suites (./tool/test.sh)
# =====================================================
#
# Uses dependency-aware trigger paths from PROJECT_DEFS so that
# a source change in a dependency also triggers tests in dependents.
# e.g., a .dart change in trial_data_types runs clinical_diary tests.

echo -e "${BLUE}Running test suites...${NC}"
echo ""

# Find projects whose trigger paths have source file changes
TEST_DIRS=""
for project_def in "${PROJECT_DEFS[@]}"; do
    IFS='|' read -r name pubspec triggers <<< "$project_def"

    PROJECT_DIR=$(dirname "$pubspec")
    TEST_SCRIPT="$REPO_ROOT/$PROJECT_DIR/tool/test.sh"

    # Skip if no test script
    if [ ! -f "$TEST_SCRIPT" ] || [ ! -x "$TEST_SCRIPT" ]; then
        continue
    fi

    # Check if any trigger path has source file changes
    should_test=false
    for trigger in $triggers; do
        relevant=$(echo "$CHANGED_FILES" | grep "^${trigger}" | grep -E '\.(dart)$|tool/test\.sh$' || true)
        if [ -n "$relevant" ]; then
            should_test=true
            break
        fi
    done

    if [ "$should_test" = true ]; then
        if ! echo "$TEST_DIRS" | grep -q "^$PROJECT_DIR$"; then
            TEST_DIRS="$TEST_DIRS
$PROJECT_DIR"
        fi
    fi
done

# Remove leading newline
TEST_DIRS=$(echo "$TEST_DIRS" | sed '/^$/d')

if [ -n "$TEST_DIRS" ]; then
    while IFS= read -r app_dir; do
        TEST_SCRIPT="$REPO_ROOT/$app_dir/tool/test.sh"
        echo -e "${BLUE}Running tests for: $app_dir${NC}"
        echo ""

        # Resolve dependencies before running tests
        PUBSPEC_FILE="$REPO_ROOT/$app_dir/pubspec.yaml"
        if [ -f "$PUBSPEC_FILE" ]; then
            if grep -q "flutter:" "$PUBSPEC_FILE" 2>/dev/null && command -v flutter &> /dev/null; then
                (cd "$REPO_ROOT/$app_dir" && flutter pub get --suppress-analytics) > /dev/null 2>&1 || true
            elif command -v dart &> /dev/null; then
                (cd "$REPO_ROOT/$app_dir" && dart pub get) > /dev/null 2>&1 || true
            fi
        fi

        # Run unit tests only (integration tests require system deps like cmake/xvfb)
        if ! "$TEST_SCRIPT" -u; then
            VALIDATION_FAILED=true
            echo ""
            echo -e "${RED}Tests failed in $app_dir${NC}"
            echo ""
        else
            echo ""
            echo -e "${GREEN}Tests passed in $app_dir${NC}"
            echo ""
        fi
    done <<< "$TEST_DIRS"
else
    echo -e "${BLUE}No app directories with test.sh affected by changes${NC}"
    echo ""
fi

# =====================================================
# 8. Auto-Bump Build Numbers (+N in pubspec.yaml)
# =====================================================
#
# Detects which Dart/Flutter projects have source changes
# (including dependencies) and increments the +N build number.
# Creates a commit with the bumped versions so the push
# includes the updated build numbers.
#
# IMPORTANT: Only bumps ONCE per PR. If the pubspec.yaml
# already has a higher build number than origin/main, we
# skip re-bumping. This prevents infinite increments on
# repeated push attempts.
#
# Project trigger paths include transitive dependencies:
# e.g., a change in trial_data_types bumps clinical_diary.

echo -e "${BLUE}Checking build number bumps...${NC}"
echo ""

# Determine changed files vs main
BUMP_BASE_BRANCH="origin/main"
if ! git rev-parse --verify "$BUMP_BASE_BRANCH" &>/dev/null; then
    BUMP_BASE_BRANCH="main"
fi

BUMP_CHANGED_FILES=""
if git rev-parse --verify "$BUMP_BASE_BRANCH" &>/dev/null; then
    BUMP_CHANGED_FILES=$(git diff --name-only "$BUMP_BASE_BRANCH"...HEAD 2>/dev/null || true)
fi

if [ -n "$BUMP_CHANGED_FILES" ]; then
    # Reuse PROJECT_DEFS defined before section 7

    BUMPED_LIST=""

    for project_def in "${PROJECT_DEFS[@]}"; do
        IFS='|' read -r name pubspec triggers <<< "$project_def"

        FULL_PUBSPEC="$REPO_ROOT/$pubspec"

        # Skip if pubspec doesn't exist
        if [ ! -f "$FULL_PUBSPEC" ]; then
            continue
        fi

        # Check if any trigger path matches a changed file
        should_bump=false
        own_dir=$(dirname "$pubspec")/
        for trigger in $triggers; do
            if echo "$BUMP_CHANGED_FILES" | grep -q "^${trigger}"; then
                if [ "$trigger" = "$own_dir" ]; then
                    # Own directory: exclude pubspec changes (avoid self-trigger)
                    relevant=$(echo "$BUMP_CHANGED_FILES" | grep "^${trigger}" | grep -v "pubspec.yaml" | grep -v "pubspec.lock" || true)
                else
                    # Dependency directory: allow all changes including pubspec bumps (cascade)
                    relevant=$(echo "$BUMP_CHANGED_FILES" | grep "^${trigger}" || true)
                fi
                if [ -n "$relevant" ]; then
                    should_bump=true
                    break
                fi
            fi
        done

        if [ "$should_bump" = true ]; then
            current=$(grep '^version:' "$FULL_PUBSPEC" | sed 's/version: //')

            # Parse current build number
            if [[ "$current" == *"+"* ]]; then
                current_build="${current##*+}"
            else
                current_build=0
            fi

            # Get the build number from origin/main for comparison
            main_version=$(git show "$BUMP_BASE_BRANCH:$pubspec" 2>/dev/null | grep '^version:' | sed 's/version: //' || true)
            if [ -n "$main_version" ] && [[ "$main_version" == *"+"* ]]; then
                main_build="${main_version##*+}"
            else
                main_build=0
            fi

            # Only bump if we haven't already bumped above main's build number
            if [ "$current_build" -gt "$main_build" ]; then
                echo -e "  ${BLUE}$name: already bumped ($current, main has $main_version) - skipping${NC}"
                continue
            fi

            base_version="${current%%+*}"
            new_build=$((main_build + 1))
            new_version="${base_version}+${new_build}"

            # Update pubspec.yaml (portable: works on both BSD and GNU sed)
            if sed --version >/dev/null 2>&1; then
                # GNU sed
                sed -i "s/^version: .*/version: ${new_version}/" "$FULL_PUBSPEC"
            else
                # BSD sed (macOS)
                sed -i '' "s/^version: .*/version: ${new_version}/" "$FULL_PUBSPEC"
            fi

            echo -e "  ${GREEN}$name: $current -> $new_version${NC}"
            BUMPED_LIST="${BUMPED_LIST} ${name}"
        fi
    done

    if [ -n "$BUMPED_LIST" ]; then
        echo ""
        echo -e "${BLUE}Committing build number bumps...${NC}"

        # Stage only the pubspec.yaml files we modified
        for project_def in "${PROJECT_DEFS[@]}"; do
            IFS='|' read -r name pubspec triggers <<< "$project_def"
            if echo "$BUMPED_LIST" | grep -q "$name"; then
                git add "$REPO_ROOT/$pubspec"
            fi
        done

        git commit -m "Bump build numbers for${BUMPED_LIST}" --no-verify

        echo -e "${GREEN}Build numbers bumped for:${BUMPED_LIST}${NC}"
    else
        echo -e "${BLUE}No projects need build number bumps${NC}"
    fi
else
    echo -e "${BLUE}No changed files detected - skipping build number bumps${NC}"
fi

echo ""

# =====================================================
# 9. Handle Validation Results
# =====================================================

echo ""
echo -e "${BLUE}======================================${NC}"
echo -e "${BLUE}  Validation Summary${NC}"
echo -e "${BLUE}======================================${NC}"
echo ""

if [ "$VALIDATION_FAILED" = true ]; then
    if [ "$SHOULD_BLOCK" = true ]; then
        # PR exists or PR-intended branch - BLOCK the push
        echo -e "${RED}VALIDATION FAILED${NC}"
        echo ""
        if [ "$HAS_PR" = true ]; then
            echo -e "${RED}Push BLOCKED because branch has an open PR.${NC}"
        elif [ "$IS_PR_INTENDED_BRANCH" = true ]; then
            echo -e "${RED}Push BLOCKED because this is a PR-intended branch (feature/fix/release).${NC}"
        fi
        echo -e "${RED}PR branches must pass all validations.${NC}"
        echo ""
        echo "To fix:"
        echo "  1. Review the validation errors above"
        echo "  2. Fix the issues in your code"
        echo "  3. Commit the fixes"
        echo "  4. Push again"
        echo ""
        echo -e "${YELLOW}To bypass (NOT RECOMMENDED):${NC}"
        echo "  git push --no-verify"
        echo ""
        exit 1
    else
        # No PR and not a PR-intended branch - warn but allow push
        echo -e "${YELLOW}VALIDATION FAILED (warnings only)${NC}"
        echo ""
        echo -e "${YELLOW}Push ALLOWED because branch has no open PR.${NC}"
        echo -e "${YELLOW}Fix these issues before creating a PR.${NC}"
        echo ""
        exit 0
    fi
else
    echo -e "${GREEN}ALL VALIDATIONS PASSED${NC}"
    echo ""
    exit 0
fi
