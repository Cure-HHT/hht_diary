#!/bin/bash
# =====================================================
# Pre-Commit Hook: Plugin Orchestrator
# =====================================================
#
# IMPLEMENTS REQUIREMENTS:
#   REQ-d00018: Git Hook Implementation
#   REQ-o00053: Branch Protection Enforcement
#
# Auto-discovers and executes pre-commit hooks from all
# installed Claude Code plugins via anspar-wf.
#
# Plugin Discovery:
#   Scans: $ANSPAR_WF_PLUGINS/*/hooks/pre-commit (or ~/anspar-wf/plugins/plugins)
#   Executes: All found hooks in alphabetical order
#
# Built-in Checks:
#   - Branch health (blocks commits on merged branches)
#   - Branch protection (blocks commits to main/master)
#   - Ticket-branch consistency (warns on mismatch)
#   - Dockerfile linting (if hadolint available)
#   - Dart code quality (dart format + dart analyze)
#   - TypeScript code quality (ESLint)
#   - Markdown linting (if markdownlint available)
#
# To install this hook:
#   git config core.hooksPath .githooks
#
# To bypass (NOT RECOMMENDED):
#   git commit --no-verify
#
# =====================================================

set -e

# =====================================================
# anspar-wf plugin path (installed via pip)
# =====================================================
ANSPAR_PLUGINS="${ANSPAR_WF_PLUGINS:-$HOME/anspar-wf/plugins/plugins}"

# =====================================================
# Portable version comparison (macOS BSD sort lacks -V)
# =====================================================
_ver_lt() {
    # Returns 0 (true) if $1 < $2 using numeric dot-separated comparison
    local IFS=.
    local i a=($1) b=($2)
    for ((i=0; i<${#b[@]}; i++)); do
        [[ -z "${a[i]}" ]] && a[i]=0
        if ((10#${a[i]} < 10#${b[i]})); then return 0; fi
        if ((10#${a[i]} > 10#${b[i]})); then return 1; fi
    done
    return 1
}

# =====================================================
# 0. Branch Health Check - Block Commits on Merged Branches
# =====================================================

BRANCH_HEALTH_SCRIPT="$ANSPAR_PLUGINS/workflow/scripts/branch-health-check.sh"

if [ -x "$BRANCH_HEALTH_SCRIPT" ]; then
    BRANCH_HEALTH_JSON=$("$BRANCH_HEALTH_SCRIPT" --format=json 2>/dev/null || echo '{"status": "error", "canWork": true}')
    BRANCH_STATUS=$(echo "$BRANCH_HEALTH_JSON" | jq -r '.status // "error"' 2>/dev/null || echo "error")
    CAN_WORK=$(echo "$BRANCH_HEALTH_JSON" | jq -r '.canWork // true' 2>/dev/null || echo "true")
    BRANCH_NAME=$(echo "$BRANCH_HEALTH_JSON" | jq -r '.branch // "unknown"' 2>/dev/null || echo "unknown")
    BRANCH_MESSAGE=$(echo "$BRANCH_HEALTH_JSON" | jq -r '.message // ""' 2>/dev/null || echo "")

    if [ "$CAN_WORK" = "false" ]; then
        echo "‚õî ERROR: Cannot commit to this branch!"
        echo ""
        echo "Branch: $BRANCH_NAME"
        echo "Status: $BRANCH_STATUS"
        echo "$BRANCH_MESSAGE"
        echo ""
        echo "Create a new branch from main:"
        echo "  git checkout -b feature/NEW-TICKET-ID origin/main"
        echo ""
        exit 1
    fi
fi

# =====================================================
# 0.1. Branch Protection - Block Commits to Main
# =====================================================

CURRENT_BRANCH=$(git branch --show-current)

if [ "$CURRENT_BRANCH" = "main" ] || [ "$CURRENT_BRANCH" = "master" ]; then
    echo "‚ùå ERROR: Direct commits to '$CURRENT_BRANCH' branch are not allowed!"
    echo ""
    echo "This repository enforces a feature branch workflow."
    echo "All changes must go through pull requests."
    echo ""
    echo "To fix this:"
    echo "  1. Create a feature branch: git checkout -b feature/your-feature-name"
    echo "  2. Commit your changes to the feature branch"
    echo "  3. Push and create a pull request"
    echo ""
    echo "To move this commit to a feature branch:"
    echo "  git branch feature/your-feature-name"
    echo "  git reset --soft HEAD~1"
    echo "  git checkout feature/your-feature-name"
    echo "  git commit"
    echo ""
    exit 1
fi

# =====================================================
# 0.2. Ticket-Branch Consistency Check (Warning Only)
# =====================================================
# Warns if the branch name doesn't match the claimed ticket

GET_ACTIVE_TICKET="$ANSPAR_PLUGINS/workflow/scripts/get-active-ticket.sh"

if [ -x "$GET_ACTIVE_TICKET" ]; then
    ACTIVE_TICKET=$("$GET_ACTIVE_TICKET" --format=id 2>/dev/null || echo "")

    if [ -n "$ACTIVE_TICKET" ]; then
        CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "")

        if [ -n "$CURRENT_BRANCH" ]; then
            # Extract ticket ID from branch name (e.g., feature/CUR-412-something -> CUR-412)
            BRANCH_TICKET=$(echo "$CURRENT_BRANCH" | grep -oE 'CUR-[0-9]+' | head -1 || echo "")

            if [ -n "$BRANCH_TICKET" ] && [ "$BRANCH_TICKET" != "$ACTIVE_TICKET" ]; then
                echo "‚ö†Ô∏è  WARNING: Ticket-branch mismatch detected!"
                echo ""
                echo "   Active ticket: $ACTIVE_TICKET"
                echo "   Branch ticket: $BRANCH_TICKET"
                echo "   Branch name:   $CURRENT_BRANCH"
                echo ""
                echo "   You are committing to a branch for a different ticket."
                echo "   If this is intentional, you can continue."
                echo ""
                echo "   To switch tickets: $ANSPAR_PLUGINS/workflow/scripts/switch-ticket.sh $BRANCH_TICKET"
                echo "   To continue anyway: This is just a warning, commit will proceed."
                echo ""
            fi
        fi
    fi
fi

# =====================================================
# 0.3. Load Central Version Pinning & Tool Version Checks
# =====================================================

if [ -f .github/versions.env ]; then
    while IFS='=' read -r key value; do
        [[ "$key" =~ ^#.*$ ]] && continue
        [[ -z "$key" ]] && continue
        key=$(echo "$key" | xargs)
        value=$(echo "$value" | xargs)
        export "${key}=${value}"
    done < .github/versions.env
fi

# Check elspais version against minimum required
if [ -n "$ELSPAIS_VERSION" ]; then
    if command -v elspais &> /dev/null; then
        INSTALLED_ELSPAIS=$(elspais --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
        if [ -n "$INSTALLED_ELSPAIS" ]; then
            if _ver_lt "$INSTALLED_ELSPAIS" "$ELSPAIS_VERSION"; then
                echo "‚ùå ERROR: elspais $INSTALLED_ELSPAIS is older than required $ELSPAIS_VERSION"
                echo ""
                echo "   Update with one of:"
                echo "     pip install --upgrade elspais"
                echo "     pipx upgrade elspais"
                echo "     brew tap anspar-org/anspar && brew upgrade elspais"
                echo ""
                exit 1
            fi
        fi
    else
        echo "‚ùå ERROR: elspais is not installed (required: >= $ELSPAIS_VERSION)"
        echo ""
        echo "   Install with one of:"
        echo "     pip install elspais"
        echo "     pipx install elspais"
        echo "     brew tap anspar-org/anspar && brew install elspais"
        echo ""
        exit 1
    fi
fi

# =====================================================
# 1. Auto-Discover and Execute Plugin Hooks
# =====================================================

PLUGIN_DIR="$ANSPAR_PLUGINS"

if [ -d "$PLUGIN_DIR" ]; then
    # Find all plugin pre-commit hooks
    PLUGIN_HOOKS=$(find "$PLUGIN_DIR" -type f -path "*/hooks/pre-commit" 2>/dev/null | sort)

    if [ -n "$PLUGIN_HOOKS" ]; then
        while IFS= read -r hook; do
            PLUGIN_NAME=$(echo "$hook" | sed 's|.*/plugins/\([^/]*\)/.*|\1|')

            # Execute the hook if it's executable
            if [ -x "$hook" ]; then
                if ! "$hook"; then
                    echo ""
                    echo "‚ùå Plugin hook failed: $PLUGIN_NAME"
                    echo "   Hook: $hook"
                    exit 1
                fi
            fi
        done <<< "$PLUGIN_HOOKS"
    fi
fi

# =====================================================
# 2. Dart Code Quality (Format + Analyze)
# =====================================================
# For Dart code changes in apps/ directory:
#   - Run dart format on changed files
#   - Run dart analyze and reject commit if it fails

DART_FILES_CHANGED=$(git diff --cached --name-only --diff-filter=ACM | grep '^apps/.*\.dart$' || true)

if [ -n "$DART_FILES_CHANGED" ]; then
    echo "üéØ Checking Dart code quality..."
    echo ""

    # Check if dart is available
    if ! command -v dart &> /dev/null; then
        echo "‚ùå ERROR: dart is not installed but Dart files are being committed!"
        echo ""
        echo "Dart files changed:"
        echo "$DART_FILES_CHANGED" | sed 's/^/  - /'
        echo ""
        echo "Please install Flutter/Dart to commit Dart files."
        echo "See: https://docs.flutter.dev/get-started/install"
        echo ""
        echo "To bypass this check (NOT RECOMMENDED):"
        echo "  git commit --no-verify"
        exit 1
    fi

    # Find all unique Dart project directories affected
    DART_PROJECTS=""
    while IFS= read -r dart_file; do
        # Walk up to find pubspec.yaml
        DIR=$(dirname "$dart_file")
        while [ "$DIR" != "." ] && [ "$DIR" != "/" ]; do
            if [ -f "$DIR/pubspec.yaml" ]; then
                # Add to list if not already present
                if ! echo "$DART_PROJECTS" | grep -q "^$DIR$"; then
                    DART_PROJECTS="$DART_PROJECTS
$DIR"
                fi
                break
            fi
            DIR=$(dirname "$DIR")
        done
    done <<< "$DART_FILES_CHANGED"

    # Remove leading newline
    DART_PROJECTS=$(echo "$DART_PROJECTS" | sed '/^$/d')

    if [ -n "$DART_PROJECTS" ]; then
        DART_FAILED=0

        while IFS= read -r project; do
            echo "  üìÅ Project: $project"

            # Run dart format
            echo "     Running dart format..."
            if ! (cd "$project" && dart format . --set-exit-if-changed > /dev/null 2>&1); then
                echo "     ‚ö†Ô∏è  Files need formatting. Applying fixes..."
                (cd "$project" && dart format .)
                # Re-stage formatted files
                git diff --name-only "$project" | xargs -I {} git add "{}" 2>/dev/null || true
                echo "     ‚úÖ Formatted files have been staged"
            else
                echo "     ‚úÖ Format OK"
            fi

            # Run dart analyze
            echo "     Running dart analyze..."
            if ! (cd "$project" && dart analyze --fatal-infos 2>&1); then
                echo ""
                echo "‚ùå Dart analyze failed in $project"
                DART_FAILED=1
            else
                echo "     ‚úÖ Analyze OK"
            fi
            echo ""
        done <<< "$DART_PROJECTS"

        if [ $DART_FAILED -eq 1 ]; then
            echo "‚ùå Dart code quality checks failed!"
            echo ""
            echo "Fix the analysis errors above before committing."
            echo ""
            echo "To bypass this check (NOT RECOMMENDED):"
            echo "  git commit --no-verify"
            exit 1
        fi

        echo "‚úÖ Dart code quality checks passed!"
        echo ""
    fi
fi

# =====================================================
# 3. TypeScript Code Quality (ESLint)
# =====================================================
# For TypeScript code changes in apps/ directory:
#   - Run ESLint and reject commit if it fails

TS_FILES_CHANGED=$(git diff --cached --name-only --diff-filter=ACM | grep -E '^apps/.*\.(ts|tsx)$' || true)

if [ -n "$TS_FILES_CHANGED" ]; then
    echo "üìò Checking TypeScript code quality..."
    echo ""

    # Find all unique TS project directories affected (containing package.json)
    TS_PROJECTS=""
    while IFS= read -r ts_file; do
        # Walk up to find package.json
        DIR=$(dirname "$ts_file")
        while [ "$DIR" != "." ] && [ "$DIR" != "/" ]; do
            if [ -f "$DIR/package.json" ]; then
                # Check if package.json has a lint script
                if grep -q '"lint"' "$DIR/package.json" 2>/dev/null; then
                    # Add to list if not already present
                    if ! echo "$TS_PROJECTS" | grep -q "^$DIR$"; then
                        TS_PROJECTS="$TS_PROJECTS
$DIR"
                    fi
                fi
                break
            fi
            DIR=$(dirname "$DIR")
        done
    done <<< "$TS_FILES_CHANGED"

    # Remove leading newline
    TS_PROJECTS=$(echo "$TS_PROJECTS" | sed '/^$/d')

    if [ -n "$TS_PROJECTS" ]; then
        TS_FAILED=0

        while IFS= read -r project; do
            echo "  üìÅ Project: $project"

            # Ensure node_modules exists
            if [ ! -d "$project/node_modules" ]; then
                echo "     Installing dependencies..."
                (cd "$project" && npm install --silent)
            fi

            # Run ESLint
            echo "     Running ESLint..."
            if ! (cd "$project" && npm run lint 2>&1); then
                echo ""
                echo "‚ùå ESLint failed in $project"
                TS_FAILED=1
            else
                echo "     ‚úÖ ESLint OK"
            fi
            echo ""
        done <<< "$TS_PROJECTS"

        if [ $TS_FAILED -eq 1 ]; then
            echo "‚ùå TypeScript code quality checks failed!"
            echo ""
            echo "Fix the lint errors above before committing."
            echo ""
            echo "To bypass this check (NOT RECOMMENDED):"
            echo "  git commit --no-verify"
            exit 1
        fi

        echo "‚úÖ TypeScript code quality checks passed!"
        echo ""
    fi
fi

# =====================================================
# 4. Requirement Hash Update (elspais)
# =====================================================
# Auto-update stale requirement hashes before commit
# This ensures hashes are always current

SPEC_FILES_CHANGED=$(git diff --cached --name-only --diff-filter=ACM | grep '^spec/.*\.md$' || true)

if [ -n "$SPEC_FILES_CHANGED" ]; then
    echo "üìã Updating requirement hashes..."
    echo ""

    if command -v elspais &> /dev/null; then
        # Run hash update (modifies files in place)
        if elspais hash update 2>&1; then
            # Re-stage any files that were modified
            echo "$SPEC_FILES_CHANGED" | xargs git add 2>/dev/null || true
            echo "‚úÖ Requirement hashes updated!"
        else
            echo "‚ö†Ô∏è  Hash update had issues (continuing anyway)"
        fi
        echo ""
    else
        echo "‚ö†Ô∏è  WARNING: elspais not installed - skipping hash update"
        echo "   Install: pip install elspais"
        echo ""
    fi
fi

# =====================================================
# 5. Markdown Linting (Built-in)
# =====================================================

# Check if any markdown files are being committed
MARKDOWN_FILES_CHANGED=$(git diff --cached --name-only --diff-filter=ACM | grep '\.md$' | grep -v 'untracked-notes/' || true)

if [ -n "$MARKDOWN_FILES_CHANGED" ]; then
    echo "üìù Linting markdown files..."
    echo ""

    # Check if markdownlint-cli is installed
    if command -v markdownlint &> /dev/null; then
        MARKDOWNLINT_FAILED=0

        # Lint all staged markdown files at once
        if ! echo "$MARKDOWN_FILES_CHANGED" | xargs markdownlint --config .markdownlint.json; then
            MARKDOWNLINT_FAILED=1
        fi

        if [ $MARKDOWNLINT_FAILED -eq 1 ]; then
            echo ""
            echo "‚ùå Markdown linting failed!"
            echo ""
            echo "Fix the errors above before committing."
            echo ""
            echo "Common fixes:"
            echo "  - MD060: Ensure table separators match cell style (compact: | --- |)"
            echo ""
            echo "To bypass this check (NOT RECOMMENDED):"
            echo "  git commit --no-verify"
            exit 1
        fi

        echo ""
        echo "‚úÖ Markdown linting passed!"
        echo ""
    else
        echo "‚ö†Ô∏è  WARNING: markdownlint not installed - skipping markdown linting"
        echo "   Install: npm install -g markdownlint-cli@${MARKDOWNLINT_CLI_VERSION:-latest}"
        echo ""
    fi
fi

# =====================================================
# 6. Auto-Bump Build Numbers (+N in pubspec.yaml)
# =====================================================
#
# On PR-intended branches, detects which Dart/Flutter projects
# have source changes (including via dependencies) and increments
# the +N build number. Bumped files are staged so they become
# part of the developer's commit ‚Äî no separate bump commit needed.
#
# IMPORTANT: Only bumps ONCE per PR. If the pubspec.yaml
# already has a higher build number than origin/main, we
# skip re-bumping. This prevents infinite increments on
# repeated commits.

# Skip bumps on main/master (already checked above, but be safe)
if [ "$CURRENT_BRANCH" != "main" ] && [ "$CURRENT_BRANCH" != "master" ]; then

    # Load shared project definitions
    HOOK_DIR=$(cd "$(dirname "$0")" && pwd)
    source "$HOOK_DIR/project-defs.sh"

    # Get repo root
    REPO_ROOT=$(git rev-parse --show-toplevel)

    # Combine staged files + branch history for trigger matching
    BUMP_BASE_BRANCH="origin/main"
    if ! git rev-parse --verify "$BUMP_BASE_BRANCH" &>/dev/null; then
        BUMP_BASE_BRANCH="main"
    fi

    BUMP_CHANGED_FILES=""
    if git rev-parse --verify "$BUMP_BASE_BRANCH" &>/dev/null; then
        # Staged files (current commit) + branch history (previous commits)
        BUMP_CHANGED_FILES=$({ git diff --cached --name-only; git diff --name-only "$BUMP_BASE_BRANCH"...HEAD 2>/dev/null; } | sort -u)
    else
        BUMP_CHANGED_FILES=$(git diff --cached --name-only)
    fi

    if [ -n "$BUMP_CHANGED_FILES" ]; then
        BUMPED_LIST=""
        # Collect projects that need lock file refresh (pubspec path)
        BUMPED_PUBSPECS=()

        # --- Pass 1: Bump all pubspec.yaml versions first ---
        # This ensures all versions are updated before any pub get
        # runs, so lock files resolve the correct dependency versions.

        for project_def in "${PROJECT_DEFS[@]}"; do
            IFS='|' read -r name pubspec triggers <<< "$project_def"

            FULL_PUBSPEC="$REPO_ROOT/$pubspec"

            # Skip if pubspec doesn't exist
            if [ ! -f "$FULL_PUBSPEC" ]; then
                continue
            fi

            # Check if any trigger path matches a changed file
            should_bump=false
            own_dir=$(dirname "$pubspec")/
            for trigger in $triggers; do
                if echo "$BUMP_CHANGED_FILES" | grep -q "^${trigger}"; then
                    if [ "$trigger" = "$own_dir" ]; then
                        # Own directory: exclude pubspec changes (avoid self-trigger)
                        relevant=$(echo "$BUMP_CHANGED_FILES" | grep "^${trigger}" | grep -v "pubspec.yaml" | grep -v "pubspec.lock" || true)
                    else
                        # Dependency directory: allow all changes including pubspec bumps (cascade)
                        relevant=$(echo "$BUMP_CHANGED_FILES" | grep "^${trigger}" || true)
                    fi
                    if [ -n "$relevant" ]; then
                        should_bump=true
                        break
                    fi
                fi
            done

            if [ "$should_bump" = true ]; then
                current=$(grep '^version:' "$FULL_PUBSPEC" | sed 's/version: //')

                # Parse current build number
                if [[ "$current" == *"+"* ]]; then
                    current_build="${current##*+}"
                else
                    current_build=0
                fi

                # Get the build number from origin/main for comparison
                main_version=$(git show "$BUMP_BASE_BRANCH:$pubspec" 2>/dev/null | grep '^version:' | sed 's/version: //' || true)
                if [ -n "$main_version" ] && [[ "$main_version" == *"+"* ]]; then
                    main_build="${main_version##*+}"
                else
                    main_build=0
                fi

                # Only bump if we haven't already bumped above main's build number
                if [ "$current_build" -gt "$main_build" ]; then
                    continue
                fi

                base_version="${current%%+*}"
                new_build=$((main_build + 1))
                new_version="${base_version}+${new_build}"

                # Update pubspec.yaml (portable: works on both BSD and GNU sed)
                if sed --version >/dev/null 2>&1; then
                    sed -i "s/^version: .*/version: ${new_version}/" "$FULL_PUBSPEC"
                else
                    sed -i '' "s/^version: .*/version: ${new_version}/" "$FULL_PUBSPEC"
                fi

                # Stage the bumped pubspec.yaml
                git add "$FULL_PUBSPEC"

                BUMPED_PUBSPECS+=("$pubspec")
                echo "  üì¶ $name: $current -> $new_version"
                BUMPED_LIST="${BUMPED_LIST} ${name}"
            fi
        done

        # --- Pass 2: Refresh lock files for tracked pubspec.lock ---
        # Now that ALL pubspec.yaml versions are final, pub get will
        # resolve the correct dependency versions in each lock file.

        for pubspec in "${BUMPED_PUBSPECS[@]}"; do
            PROJECT_DIR="$REPO_ROOT/$(dirname "$pubspec")"
            LOCK_FILE="$PROJECT_DIR/pubspec.lock"

            # Only update lock files that are tracked by git
            if git ls-files --error-unmatch "$LOCK_FILE" &>/dev/null 2>&1; then
                PUB_OUTPUT=""
                PUB_EXIT=0
                if grep -q "flutter:" "$PROJECT_DIR/pubspec.yaml" 2>/dev/null && command -v flutter &>/dev/null; then
                    PUB_OUTPUT=$( (cd "$PROJECT_DIR" && flutter pub get --suppress-analytics) 2>&1) || PUB_EXIT=$?
                elif command -v dart &>/dev/null; then
                    PUB_OUTPUT=$( (cd "$PROJECT_DIR" && dart pub get) 2>&1) || PUB_EXIT=$?
                fi

                if [ "$PUB_EXIT" -ne 0 ]; then
                    echo "  ‚ö†Ô∏è  pub get failed in $(dirname "$pubspec") (exit $PUB_EXIT)"
                    echo "     $PUB_OUTPUT" | head -5 | sed 's/^/     /'
                    echo "     Lock file may be stale ‚Äî run pub get manually."
                else
                    git add "$LOCK_FILE"
                fi
            fi
        done

        if [ -n "$BUMPED_LIST" ]; then
            echo ""
            echo "‚úÖ Build numbers bumped for:${BUMPED_LIST}"
            echo ""
        fi
    fi
fi

# =====================================================
# All Validations Passed
# =====================================================

exit 0
