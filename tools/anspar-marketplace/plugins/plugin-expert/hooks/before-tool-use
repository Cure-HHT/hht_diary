#!/bin/bash
# =====================================================
# Plugin-Expert: before-tool-use Hook
# =====================================================
#
# Detects when work is being done on plugins and injects
# architectural guidance to maintain separation of concerns.
#
# Triggers when:
# - File operations in plugin directories
# - Plugin-related code changes
#
# Injects guidance to:
# - Keep plugin work inside plugin directory
# - Maintain clear separation of concerns
# - Follow plugin architecture patterns
#
# =====================================================

TOOL_NAME="${CLAUDE_TOOL_NAME:-}"
TOOL_PARAMS="${CLAUDE_TOOL_PARAMS:-}"

# Only process file operation tools
if [[ ! "$TOOL_NAME" =~ ^(Edit|Write|Read|Glob|Grep)$ ]]; then
    exit 0
fi

# Extract file paths from tool parameters
FILE_PATH=""
case "$TOOL_NAME" in
    Edit|Write|Read)
        FILE_PATH=$(echo "$TOOL_PARAMS" | jq -r '.file_path // empty' 2>/dev/null)
        ;;
    Glob)
        PATTERN=$(echo "$TOOL_PARAMS" | jq -r '.pattern // empty' 2>/dev/null)
        # Check if pattern targets plugin directories
        if [[ "$PATTERN" =~ plugins/ ]]; then
            FILE_PATH="plugins/"
        fi
        ;;
    Grep)
        SEARCH_PATH=$(echo "$TOOL_PARAMS" | jq -r '.path // empty' 2>/dev/null)
        if [[ "$SEARCH_PATH" =~ plugins/ ]]; then
            FILE_PATH="$SEARCH_PATH"
        fi
        ;;
esac

# Check if we're working on a plugin
if [[ -z "$FILE_PATH" ]]; then
    exit 0
fi

# Detect if this is plugin work
PLUGIN_DIR=""
if [[ "$FILE_PATH" =~ (tools/anspar-marketplace/plugins/|plugins/)([^/]+) ]]; then
    PLUGIN_DIR="${BASH_REMATCH[2]}"
fi

if [[ -z "$PLUGIN_DIR" ]]; then
    exit 0
fi

# =====================================================
# JSON Validation for Plugin Configuration Files
# =====================================================

# Check if this is a JSON file edit/write operation
if [[ "$TOOL_NAME" =~ ^(Edit|Write)$ ]] && [[ "$FILE_PATH" =~ \.(json)$ ]]; then
    # Check if it's a plugin.json or hooks.json file
    BASENAME=$(basename "$FILE_PATH")

    if [[ "$BASENAME" == "plugin.json" ]] || [[ "$BASENAME" == "hooks.json" ]]; then
        # Get the plugin root directory
        PLUGIN_ROOT="${FILE_PATH%/.claude-plugin/plugin.json}"
        PLUGIN_ROOT="${PLUGIN_ROOT%/hooks/hooks.json}"

        # Validation will happen after the file is written
        # For now, just inject a reminder to validate

        cat << 'EOF'

üîç JSON VALIDATION REMINDER

You're modifying a plugin configuration file. After saving:

1. Validate syntax and schema:
   ${CLAUDE_PLUGIN_ROOT}/utilities/validate-plugin-json.sh <file-path>

2. Common issues to avoid:
   ‚ùå Missing commas between properties
   ‚ùå Trailing commas in arrays/objects
   ‚ùå Missing required fields (name, version, description, author)
   ‚ùå Invalid version format (use semver: 1.0.0)
   ‚ùå Keywords as string instead of array
   ‚ùå Invalid hook structure (missing 'hooks' array)

3. After editing, I can validate it for you automatically.

EOF
    fi
fi

# =====================================================
# Inject Architectural Guidance
# =====================================================

cat << EOF

üì¶ PLUGIN ARCHITECTURE GUIDANCE

You're working on the '$PLUGIN_DIR' plugin. Please follow these principles:

üéØ Keep Plugin Work Inside Plugin Directory:
   - Plugin-specific code ‚Üí inside plugin directory
   - Scripts, utilities, agents ‚Üí inside plugin
   - Configuration ‚Üí inside plugin
   - Tests ‚Üí inside plugin/tests/

üîß Separation of Concerns:
   - Each plugin = single, clear responsibility
   - Cross-plugin features ‚Üí create orchestrator in appropriate plugin
   - Don't mix plugin concerns
   - Use sub-agents for plugin capabilities

üìã What Belongs in Plugin:
   ‚úÖ Scripts specific to plugin's domain
   ‚úÖ Utilities used only by this plugin
   ‚úÖ Configuration for this plugin
   ‚úÖ Tests for this plugin
   ‚úÖ Documentation for this plugin

üìã What Belongs Outside Plugin:
   ‚õî Generic utilities used by multiple plugins ‚Üí shared location
   ‚õî Project-wide configuration ‚Üí root config
   ‚õî Multi-plugin orchestration ‚Üí workflow plugin or new orchestrator
   ‚õî Shared data models ‚Üí shared directory

üèóÔ∏è Plugin Integration Pattern:
   Plugin A ‚îÄ‚îê
             ‚îú‚îÄ‚Üí Orchestrator (in appropriate plugin)
   Plugin B ‚îÄ‚îò

   Example: workflow/scripts/generate-commit-msg.sh orchestrates:
   - linear-integration plugin (fetch ticket)
   - workflow/scripts/parse-req-refs.sh (parse REQs)
   - WORKFLOW_STATE (cache)

‚ö†Ô∏è  If you find yourself:
   - Putting plugin A's logic in plugin B ‚Üí STOP, restructure
   - Creating cross-plugin dependencies ‚Üí Consider orchestrator pattern
   - Duplicating logic ‚Üí Extract to shared utility
   - Unsure where code belongs ‚Üí ASK USER for guidance

Remember: Clean separation = maintainable, testable, reusable code!

EOF

exit 0
